/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package it.libemax.utility;

import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.titanium.TiBlob;
import org.appcelerator.titanium.util.TiConvert;

import android.app.Activity;
import android.content.Context;
import android.content.ContentResolver;
import android.telephony.TelephonyManager;
import android.net.ConnectivityManager;
import android.provider.Settings;
import android.os.Bundle;
import android.content.SharedPreferences;
import android.location.Location;
import android.location.LocationManager;
import android.location.LocationProvider;
import android.content.res.Configuration;
import android.net.wifi.WifiManager;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Matrix;

import android.view.View;
import android.view.WindowInsets;
import android.graphics.Insets;


import java.util.TimeZone;
import java.util.HashMap;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;

@Kroll.module(name = "LibemaxUtils", id = "it.libemax.utility")
public class LibemaxUtilsModule extends KrollModule {

	// Standard Debugging variables
	private static final String LCAT = "LibemaxUtilsModule";
	private static final boolean DBG = TiConfig.LOGD;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;

	public LibemaxUtilsModule() {
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
		Log.d(LCAT, "inside onAppCreate");
		// put module init code that needs to run when the application is created
	}

	// Methods
	@Kroll.method
	public boolean isAirplaneModeOn() {

		Context context = TiApplication.getInstance();
		ContentResolver contentResolver = context.getContentResolver();

		try {
			if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) {
				// noinspection deprecation
				return Settings.System.getInt(contentResolver, Settings.System.AIRPLANE_MODE_ON, 0) != 0;
			}
			return Settings.Global.getInt(contentResolver, Settings.Global.AIRPLANE_MODE_ON, 0) != 0;
		} catch (NullPointerException e) {
			// https://github.com/square/picasso/issues/761, some devices might crash here,
			// assume that
			// airplane mode is off.
			return false;
		} catch (SecurityException e) {
			// https://github.com/square/picasso/issues/1197
			return false;
		}
	}

	@Kroll.method
	public boolean isDataOraAutomatica() {
		Context context = TiApplication.getInstance();
		ContentResolver contentResolver = context.getContentResolver();

		return Settings.Global.getInt(contentResolver, Settings.Global.AUTO_TIME, 0) != 0;
	}

	@Kroll.method
	public boolean isFusoOrarioAutomatico() {
		Context context = TiApplication.getInstance();
		ContentResolver contentResolver = context.getContentResolver();

		return Settings.Global.getInt(contentResolver, Settings.Global.AUTO_TIME_ZONE, 0) != 0;
	}

	@Kroll.method
	public boolean isMockSettingsON() {
		Context context = TiApplication.getInstance();
		/*
		 * ContentResolver contentResolver = context.getContentResolver();
		 * 
		 * return Settings.Secure.getInt(contentResolver,
		 * Settings.Secure.ALLOW_MOCK_LOCATION, 0) != 0;
		 */
		LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
		try {
			Location lastLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
			if (lastLocation == null)
				return false;

			if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) { // API 31+
				return lastLocation.isMock();
			} else {
				return lastLocation.isFromMockProvider(); // API 18+
			}
		} catch (Exception e) {
			Log.e("TI_MODULE", "Errore nel controllo mock: " + e.getMessage());
			return false;
		}
	}

	/*
	 * Metodo piÃ¹ evoliuto per wifi
	 * 
	 * @Kroll.method
	 * public boolean isWiFiOn() {
	 * Context context = TiApplication.getInstance();
	 * WifiManager wifiManager = (WifiManager)
	 * context.getSystemService(Context.WIFI_SERVICE);
	 * if (wifiManager.isWifiEnabled()) {
	 * return true;
	 * }
	 * else{
	 * return false;
	 * }
	 * }
	 */

	@Kroll.method
	public boolean isWiFiOn() {
		Context context = TiApplication.getInstance();
		ContentResolver contentResolver = context.getContentResolver();

		return Settings.Global.getInt(contentResolver, Settings.Global.WIFI_ON, 0) != 0;
	}

	@Kroll.method
	public boolean isMobileDataOn() {
		Context context = TiApplication.getInstance();
		TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
		if (tm.getSimState() == TelephonyManager.SIM_STATE_READY) {
			// return tm.isDataEnabled();
			int dataState = tm.getDataState();
			Log.d(LCAT, "tm.getDataState() : " + dataState);
			if (dataState != TelephonyManager.DATA_DISCONNECTED) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	@Kroll.method
	public long getLastBestLocation() {
		Context context = TiApplication.getInstance();
		LocationManager lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
		boolean gps_enabled = false;
		boolean network_enabled = false;

		gps_enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
		network_enabled = lm.isProviderEnabled(LocationManager.NETWORK_PROVIDER);

		Location net_loc = null, gps_loc = null, finalLoc = null;

		if (gps_enabled)
			gps_loc = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER);
		if (network_enabled)
			net_loc = lm.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);

		if (gps_loc != null && net_loc != null) {

			// smaller the number more accurate result will
			if (gps_loc.getAccuracy() > net_loc.getAccuracy())
				finalLoc = net_loc;
			else
				finalLoc = gps_loc;

			// I used this just to get an idea (if both avail, its upto you which you want
			// to take as I've taken location with more accuracy)

			return finalLoc.getTime();

		} else {

			if (gps_loc != null) {
				finalLoc = gps_loc;
				return finalLoc.getTime();
			} else if (net_loc != null) {
				finalLoc = net_loc;
				return finalLoc.getTime();
			} else
				return 0;
		}
	}

	@Kroll.method
	public String getDefaultTimezone() {
		TimeZone timeZone = TimeZone.getDefault();
		String name = timeZone.getID();
		return name;
	}

	private static KrollDict updateFormatOption(KrollDict args, String mimeType, boolean isAlphaRequired) {
		if (args == null) {
			args = new KrollDict();
		}

		ImageFormatType formatType = ImageFormatType.from(args, null);
		if (formatType == null) {
			formatType = ImageFormatType.fromMimeType(mimeType);
		}
		if ((formatType == null) || (isAlphaRequired && !formatType.isAlphaSupported())) {
			formatType = isAlphaRequired ? ImageFormatType.PNG : ImageFormatType.JPEG;
		}
		args.put(TiPropertyNames.FORMAT, formatType.toTitaniumIntegerId());
		return args;
	}

	public static TiBlob compressToBlob(Bitmap bitmap, KrollDict args, boolean isRecyclingBitmap) {
		// Validate bitmap.
		if (bitmap == null) {
			return null;
		}

		// Compress to image format (such as JPEG) and return it wrapped in a blob.
		byte[] compressedBytes = new byte[0];
		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
			if (compressToStream(bitmap, args, outputStream)) {
				compressedBytes = outputStream.toByteArray();
			}
		} catch (Throwable ex) {
			Log.e(LCAT, "Failed to compress image to blob.", ex);
		}
		if (isRecyclingBitmap) {
			bitmap.recycle();
			bitmap = null;
		}
		return TiBlob.blobFromData(compressedBytes, ImageFormatType.from(args).toMimeType());
	}

	public static boolean compressToStream(Bitmap bitmap, KrollDict args, OutputStream outputStream) {
		// Validate bitmap.
		if ((bitmap == null) || (outputStream == null)) {
			return false;
		}

		// Determine which format type to compress the bitmap to.
		ImageFormatType formatType = ImageFormatType.from(args);

		// Fetch compression quality from arguments.
		// This modules defines it as a value ranging from 0-1, which we must convert to
		// 0-100.
		int quality = 70;
		if (args != null) {
			float value = TiConvert.toFloat(args.get(TiPropertyNames.QUALITY), quality / 100.0f);
			if (value > 1.0f) {
				value = 1.0f;
			} else if (value < 0.0f) {
				value = 0.0f;
			}
			quality = (int) (value * 100.0f);
		}

		// Compress bitmap to requested image format (such as JPEG) to given stream.
		return bitmap.compress(formatType.toCompressFormat(), quality, outputStream);
	}

	private static Matrix createUprightMatrixFrom(Bitmap bitmap, TiExifOrientation exifOrientation) {
		Matrix matrix = new Matrix();
		if ((bitmap != null) && (exifOrientation != null) && (exifOrientation != TiExifOrientation.UPRIGHT)) {
			float width = !exifOrientation.isSideways() ? bitmap.getWidth() : bitmap.getHeight();
			float height = !exifOrientation.isSideways() ? bitmap.getHeight() : bitmap.getWidth();
			matrix.postRotate(exifOrientation.getDegreesCounterClockwise());
			switch (exifOrientation.getDegreesCounterClockwise()) {
				case 90:
					matrix.postTranslate(width, 0);
					break;
				case 180:
					matrix.postTranslate(width, height);
					break;
				case 270:
					matrix.postTranslate(0, height);
					break;
			}
			if (exifOrientation.isMirrored()) {
				matrix.postScale(-1.0f, 1.0f, width * 0.5f, 0.0f);
			}
		}
		return matrix;
	}

	public static Bitmap imageRotate(Bitmap bitmap, KrollDict args, TiExifOrientation exifOrientation) {
		// Validate given bitmap.
		if (bitmap == null) {
			return null;
		}

		// Make sure the rest of the params are defined.
		if (args == null) {
			args = new KrollDict();
		}
		if (exifOrientation == null) {
			exifOrientation = TiExifOrientation.UPRIGHT;
		}

		// Create a new rotated bitmap.
		Matrix matrix = createUprightMatrixFrom(bitmap, exifOrientation);
		matrix.postRotate(args.optInt(TiPropertyNames.DEGREES, 90));
		return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
	}

	@Kroll.method
	public TiBlob imageWithRotation(TiBlob blob, HashMap args) {
		KrollDict arg = new KrollDict(args);
		if (blob == null) {
			return null;
		}
		arg = updateFormatOption(arg, blob.getMimeType(), false);
		Bitmap oldBitmap = blob.getImage();
		Bitmap newBitmap = imageRotate(oldBitmap, arg, TiExifOrientation.from(blob));
		return compressToBlob(newBitmap, arg, (newBitmap != oldBitmap));
	}

	@Kroll.method
	public KrollDict getSafeAreaInsets() {
		KrollDict result = new KrollDict();
		Activity activity = TiApplication.getAppCurrentActivity();

		if (activity == null) {
			return result;
		}

		View rootView = activity.getWindow().getDecorView();

		if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {
			WindowInsets insets = rootView.getRootWindowInsets();
			if (insets != null) {
				Insets sysInsets = insets.getInsets(WindowInsets.Type.systemBars());
				float density = activity.getResources().getDisplayMetrics().density;
				result.put("top", Math.round(sysInsets.top / density));
            	result.put("bottom", Math.round(sysInsets.bottom / density));
            	result.put("left", Math.round(sysInsets.left / density));
            	result.put("right", Math.round(sysInsets.right / density));
			}
		} else {
				result.put("top", 0);
				result.put("bottom", 0);
				result.put("left", 0);
				result.put("right", 0);
		}

		return result;
	}
	
}
